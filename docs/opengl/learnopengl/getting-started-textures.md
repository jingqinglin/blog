我们可以为每个顶点添加颜色来增加图形的细节，从而创建出有趣的图像。但是，如果想让图形看起来更真实，我们就必须有足够多的顶点，从而指定足够多的颜色。这将会产生很多额外开销，因为每个模型都会需求更多的顶点，每个顶点又需求一个颜色属性。

艺术家和程序员更喜欢使用纹理（Texture）。纹理是一个 2D 图片（甚至也有 1D 和 3D 的纹理），它可以用来添加物体的细节；你可以想象纹理是一张绘有砖块的纸，无缝折叠贴合到你的 3D 的房子上。因为我们可以在一张图片上插入非常多的细节，这样就可以让物体非常精细而不用指定额外的顶点。

为了能够把纹理映射到三角形上，我们需要指定三角形的每个顶点各自对应纹理的哪个部分。这样每个顶点就会关联着一个**纹理坐标**（Texture Coordinate），用来标明该从纹理图像的哪个部分采样（采集片段颜色）。之后在图形的其它片段上进行片段插值（Fragment Interpolation）。

纹理坐标在 x 和 y 轴上，范围为 0 到 1 之间（我们使用的是 2D 纹理图像）。使用纹理坐标获取纹理颜色叫做采样（Sampling）。纹理坐标起始于 $(0, 0)$，也就是纹理图片的左下角，终于 $(1, 1)$。下面的图片展示了我们是如何把纹理坐标映射到三角形上的。

![](_images/learnopengl-getting-started-17.png)

```cpp
float texCoords[] = {
    0.0f, 0.0f, // 左下角
    1.0f, 0.0f, // 右下角
    0.5f, 1.0f // 上中
};
```

## 纹理环绕方式

纹理坐标的范围通常是从$(0, 0)$ 到 $(1, 1)$，那如果我们把纹理坐标设置在范围之外会发生什么？OpenGL 默认的行为是重复这个纹理图像，但 OpenGL 提供了更多的选择：

| 环绕方式             | 描述                                                                                     |
| -------------------- | ---------------------------------------------------------------------------------------- |
| `GL_REPEAT`          | 对纹理的默认行为，重复纹理图像                                                           |
| `GL_MIRRORED_REPEAT` | 和 `GL_REPEAT` 一样，但每次重复图片是镜像放置的                                          |
| `GL_CLAMP_TO_EDGE`   | 纹理坐标会被约束在 0 到 1 之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果 |
| `GL_CLAMP_TO_BORDER` | 超出的坐标为用户指定的边缘颜色                                                           |

![](_images/learnopengl-getting-started-18.png)


## 纹理过滤

> [!DANGER]
> 前面的笔记大多都是复制教程里的文字，还不如直接看教程。笔记应该记录难点、易忘点，以大纲的形式比较好。

>当物体很大但是纹理的分辨率很低要进行纹理过滤

- **纹理像素**和**纹理坐标**：纹理坐标是给模型顶点设置的那个数组，OpenGL 以这个顶点的纹理坐标数据去查找纹理图像上的像素，然后进行采样提取纹理像素的颜色
- **临近过滤**：选择中心点最接近纹理坐标的那个像素。偏像素风
- **线性过滤**：一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大。更平滑
- **多级渐远纹理**（MipMap）：多级渐远纹理级别之间的过滤方式（有点不懂）

## 加载与创建纹理

- stb_image.h：它一个支持多种流行格式的图像加载库（纹理图像可能被储存为各种各样的格式）